<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Kolt Obfuscate</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: linear-gradient(to bottom, #090909, #0e0e15);
      font-family: monospace;
      color: #e0e0e0;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      padding: 40px 20px;
      overflow-x: hidden;
      position: relative;
    }
    .glass {
      backdrop-filter: blur(12px);
      background: rgba(20, 20, 30, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 16px;
      padding: 25px;
      width: 100%;
      max-width: 980px;
      box-shadow: 0 0 40px rgba(0, 0, 0, 0.4);
      position: relative;
      z-index: 2;
    }
    h1 {
      color: #72dfff;
      text-align: center;
      margin-bottom: 20px;
      font-size: 2rem;
    }
    textarea {
      width: 100%;
      height: 280px;
      background: #1e1e2b;
      border: 1px solid #333;
      border-radius: 10px;
      padding: 15px;
      font-size: 16px;
      color: #cfd8dc;
      resize: vertical;
      margin-bottom: 10px;
      font-family: monospace;
    }
    input[type=text].honeypot {
      display: none;
    }
    .button-scroll {
      overflow-x: auto;
      margin-top: 10px;
    }
    .button-row {
      display: flex;
      gap: 12px;
      min-width: 680px;
      width: max-content;
      padding-bottom: 10px;
    }
    button {
      padding: 12px 24px;
      font-size: 16px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      white-space: nowrap;
      transition: background 0.3s;
    }
    button.obf { background: #4fc3f7; color: #000; }
    button.obf:hover { background: #039be5; }
    button.copy { background: #fbc02d; color: #000; }
    button.copy:hover { background: #f9a825; }
    button.download { background: #00c853; color: #000; }
    button.download:hover { background: #009624; }
    button.clear { background: #ef5350; color: #000; }
    button.clear:hover { background: #e53935; }
    #result {
      background: #1e1e2b;
      border: 1px solid #333;
      border-radius: 10px;
      padding: 15px;
      white-space: pre-wrap;
      word-wrap: break-word;
      font-size: 14px;
      min-height: 160px;
      margin-top: 25px;
      color: #cfd8dc;
      font-family: monospace;
    }
    .loader {
      text-align: center;
      color: #888;
      margin-bottom: 10px;
    }
    .options {
      margin-top: 30px;
      margin-bottom: 10px;
    }
    .options label {
      display: block;
      margin-top: 10px;
      margin-bottom: 4px;
      font-size: 15px;
    }
    .options input[type=range] {
      width: 100%;
    }
    .meteor {
      position: fixed;
      top: -60px;
      left: -60px;
      width: 12px;
      height: 12px;
      background: linear-gradient(45deg, #ffcc80, #ff5722, #e65100);
      border-radius: 50%;
      animation: meteorFall 4s linear infinite;
      box-shadow: 0 0 8px #ff9100;
      z-index: 0;
    }
    @keyframes meteorFall {
      0% {
        transform: translate(0, 0) rotate(45deg);
        opacity: 1;
      }
      100% {
        transform: translate(1200px, 1000px) rotate(45deg);
        opacity: 0;
      }
    }
    ::-webkit-scrollbar {
      height: 6px;
    }
    ::-webkit-scrollbar-thumb {
      background: #555;
      border-radius: 3px;
    }
  </style>
</head>
<body>

  <div class="meteor"></div>

  <div class="glass">
    <h1>Kolt Obfuscate</h1>
    <div class="loader" id="loader">üîÑ Carregando API...</div>

    <input type="text" class="honeypot" id="botCheck" autocomplete="off" />

    <textarea id="inputCode" placeholder="Cole seu script Lua aqui‚Ä¶"></textarea>

    <div class="button-scroll">
      <div class="button-row">
        <button class="obf" onclick="obfuscate()">OBFUSCATE</button>
        <button class="copy" onclick="copyToClipboard()">Copiar</button>
        <button class="download" onclick="downloadObfuscated()">Baixar</button>
        <button class="clear" onclick="clearCode()">Clear</button>
      </div>
    </div>

    <div class="options">
      <label for="junkAmount">Quantidade de lixo: <span id="junkVal">3</span></label>
      <input type="range" min="0" max="10" value="3" id="junkAmount" oninput="junkVal.textContent = this.value" />

      <label for="junkMultiplier">Multiplicador de lixo: <span id="multiVal">1</span></label>
      <input type="range" min="1" max="5" value="1" id="junkMultiplier" oninput="multiVal.textContent = this.value" />
    </div>

    <div id="result"></div>
  </div>

<script>
  let lastObf = "";

  async function loadApi() {
    const l = document.getElementById("loader");
    try {
      await new Promise(r => setTimeout(r, 400));
      l.textContent = "‚úÖ API de sintaxe e cores carregada!";
    } catch {
      l.textContent = "‚ùå Falha ao carregar API";
    }
  }

  // --- Helpers hex ---
  function toHex(n) {
    return "0x" + n.toString(16);
  }

  // Transforma string em array hex (ex: return "abc" vira 0x61 0x62 0x63)
  function stringToHexArray(str) {
    let arr = [];
    for(let i=0; i < str.length; i++) {
      arr.push(toHex(str.charCodeAt(i)));
    }
    return arr;
  }

  // Gera nomes quebrados tipo "_v_2_aB3"
  function generateBrokenVarName() {
    const letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    const nums = "0123456789";
    let name = "_v_" + Math.floor(Math.random() * 1000) + "_";
    for(let i=0; i<3; i++) {
      name += letters.charAt(Math.floor(Math.random() * letters.length));
    }
    for(let i=0; i<2; i++) {
      name += nums.charAt(Math.floor(Math.random() * nums.length));
    }
    return name;
  }

  // Camada 1 - inutilizar vari√°veis e renomear + quebrar vari√°veis em peda√ßos
  function layer1_renameVariablesAndBreak(code) {
    // Pega todas vari√°veis locais declaradas
    let vars = [];
    let regexLocal = /local\s+([A-Za-z_]\w*)/g;
    let match;
    while ((match = regexLocal.exec(code)) !== null) {
      vars.push(match[1]);
    }

    // Gera nomes quebrados e cria mapa de substitui√ß√£o
    let map = {};
    vars.forEach(v => {
      map[v] = generateBrokenVarName();
    });

    // Renomeia vari√°veis no c√≥digo (exceto declara√ß√£o)
    for(let v of vars) {
      // Para vari√°veis muito pequenas, quebre em 2 peda√ßos
      let part1 = generateBrokenVarName();
      let part2 = generateBrokenVarName();

      // Substitui declara√ß√£o local original por peda√ßos separados
      // local var --> local part1, part2; var = part1..part2
      let pattern = new RegExp(`local\\s+${v}\\b`, "g");
      code = code.replace(pattern, `local ${part1}, ${part2}`);

      // Substitui todas refer√™ncias por concatena√ß√£o dos dois peda√ßos
      let refPattern = new RegExp(`\\b${v}\\b`, "g");
      code = code.replace(refPattern, `(${part1}..${part2})`);
    }

    return code;
  }

  // Gera c√≥digo lixo (junk) com if/else in√∫teis e n√∫meros hex
  function generateJunkCode(junkCount, junkMult) {
    let junk = [];
    const randHexNum = () => "0x" + Math.floor(Math.random() * 255).toString(16).padStart(2, "0");
    for(let i=0; i < junkCount; i++) {
      for(let j=0; j < junkMult; j++) {
        // C√≥digo in√∫til: if aleat√≥rio com n√∫meros hex e else que n√£o faz nada
        junk.push(`
local junk${i}_${j} = ${randHexNum()}
if junk${i}_${j} > 0x10 then
  junk${i}_${j} = junk${i}_${j} - 0x01
else
  junk${i}_${j} = junk${i}_${j} + 0x01
end
        `);
      }
    }
    return junk.join("\n");
  }

  // Converte string para hex usando formato 0xNN separado por /
  // Exemplo: "abc" -> return({0x61/0x62/0x63})
  function stringToHexReturnFormat(str) {
    let arr = [];
    for(let i=0; i < str.length; i++) {
      arr.push(toHex(str.charCodeAt(i)));
    }
    return "return({" + arr.join("/") + "})";
  }

  // Camada 3: transforma o script inteiro em hex no formato return({0xNN/0xNN/...})
  // E embrulha no return loadstring(...) para executar
  function layer3_hexWrap(code) {
    let hexArray = stringToHexArray(code);
    let hexString = hexArray.map(h => h).join("/");
    // C√≥digo Lua que retorna um array de bytes e depois junta numa string e executa
    const luaWrapper = `
local bytes = {${hexString}}
local str = ""
for i=1,#bytes do
  str = str .. string.char(bytes[i])
end
local func = loadstring(str)
return func()
`;
    return luaWrapper;
  }

  // Adiciona muitos if else in√∫teis intercalando o c√≥digo para aumentar confus√£o
  function layer2_addIfElseConfusion(code, junkCount, junkMult) {
    let lines = code.split("\n");
    let newCode = "";
    const randHex = () => "0x" + Math.floor(Math.random() * 255).toString(16).padStart(2,"0");

    for(let i=0; i<lines.length; i++) {
      newCode += lines[i] + "\n";

      // A cada linha, adiciona um if in√∫til baseado em n√∫meros hex
      if (i % 2 === 0) {
        newCode += `if ${randHex()} > 0x50 then\n  -- junk code\nelse\n  -- junk else\nend\n`;
      }
    }

    // Acrescenta junk gerado controlado pelo usu√°rio
    newCode += generateJunkCode(junkCount, junkMult);

    return newCode;
  }

  // Fun√ß√£o principal que chama as camadas
  function process(code) {
    const junkCount = parseInt(document.getElementById("junkAmount").value);
    const junkMult = parseInt(document.getElementById("junkMultiplier").value);

    // Remove coment√°rios para n√£o complicar o parse (pode melhorar depois)
    code = code.replace(/--.*$/gm, "");

    // CAMADA 1: renomear e inutilizar vari√°veis
    code = layer1_renameVariablesAndBreak(code);

    // CAMADA 2: adicionar if/else in√∫teis e lixo
    code = layer2_addIfElseConfusion(code, junkCount, junkMult);

    // CAMADA 3: codificar em hex e transformar em loadstring execut√°vel
    code = layer3_hexWrap(code);

    // Retorna resultado com highlight simples
    const highlighted = code
      .replace(/(["'])(.*?)\1/g, '<span style="color:#c792ea;">$&</span>')
      .replace(/\b(local|function|end|for|do|if|then|else|repeat|until|load|return|and|or|not)\b/g, '<span style="color:#82aaff;">$1</span>');

    document.getElementById("result").innerHTML = highlighted;
    lastObf = code;
  }

  function obfuscate() {
    if (document.getElementById("botCheck").value !== "") {
      alert("Bot detectado. A√ß√£o bloqueada.");
      return;
    }

    let code = document.getElementById("inputCode").value;
    if (!code.trim()) {
      alert("Cole o c√≥digo!");
      return;
    }

    process(code);
  }

  function copyToClipboard() {
    if (!lastObf) return alert("Nada para copiar");
    navigator.clipboard.writeText(lastObf).then(_ => alert("Copiado!"))
      .catch(_ => alert("Falha ao copiar"));
  }

  function downloadObfuscated() {
    if (!lastObf) return alert("Nada para baixar");
    const blob = new Blob([lastObf], { type: "text/plain" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "kolt_obfuscate.lua";
    a.click();
  }

  function clearCode() {
    document.getElementById("inputCode").value = "";
    document.getElementById("result").innerHTML = "";
    lastObf = "";
  }

  loadApi();
</script>

</body>
</html>
